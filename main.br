// should be used with bruterra;
bruter.include config.br;
set List from lua.require {lib.list};
set file from lua.require {lib.file};
set io from C.eval `
#include <stdio.h>
#include <stdlib.h>
const int _EOF = EOF;
`;

set main from lua.eval 
{
    local Bytes = br.List(uint8);
    local Disk = br.List(int8);
    local Machine = br.List(Disk);
    local checkfile = terralib.includecstring([[
        #include <stdio.h>
        int checkfile(const char *path) {
            FILE *file = fopen(path, "rb");
            if (file == NULL) {
                return 0;
            }
            fclose(file);
            return 1;
        }
    ]]).checkfile;

    
    terra fileread(path:rawstring)
        if checkfile(path) == 0 then
            br.io.printf("File %s not found\n", path);
            return Disk.new();
        else 
            br.io.printf("Reading file %s\n", path);
        end
        var file:&br.io.FILE = br.io.fopen(path, "rb");
        var result:Disk = Disk.new();
        var buffer:uint8 = 0;
        while true do
            buffer = br.io.fgetc(file);
            br.io.printf("Reading file %d\n", buffer);
            if br.io._EOF == -1 then
                break;
            end
            result:push(buffer);
        end
        br.io.fclose(file);
        return result;
    end

    terra filewrite(path:rawstring, data:Disk)
        var file:&br.io.FILE = br.io.fopen(path, "wb");
        for i=0, data.size-1 do
            br.io.fputc(data.data[i], file);
        end
        br.io.fclose(file);
    end

    terra Machine:load(path:rawstring)
        self:push(fileread(path));
        br.io.printf("Loaded disk %s\n", path);
    end

    terra Machine:save(path:rawstring, diskIndex:uint8)
        filewrite(path, self.data[diskIndex]);
    end

    terra Machine:getint(diskIndex:uint8, position:uint8)
        return self.data[diskIndex].data[position] + self.data[diskIndex].data[position+1]*256 + self.data[diskIndex].data[position+2]*65536 + self.data[diskIndex].data[position+3]*16777216;
    end
    
    terra Machine:getchar(diskIndex:uint8, position:uint8)
        return self.data[diskIndex].data[position];
    end

    terra Machine:getstring(diskIndex:uint8, position:uint8, size:uint8)
        var result:Bytes = Bytes.new();
        for i=0, size-1 do
            result:push(self.data[diskIndex].data[position+i]);
        end
        return result;
    end

    local ieee754 = terralib.includecstring([[
        #include <math.h>
        
        float ieee754(unsigned char b0, unsigned char b1, unsigned char b2, unsigned char b3) {
            int sign = (b0 >> 7) & 1;
            int exponent = ((b0 & 0x7F) << 1) | ((b1 >> 7) & 1);
            int mantissa = ((b1 & 0x7F) << 16) | (b2 << 8) | b3;
            float result = 0;
            if (exponent == 0xFF) {
                if (mantissa == 0) {
                    result = sign ? -INFINITY : INFINITY;
                } else {
                    result = NAN;
                }
            } else {
                result = ldexpf((float)mantissa / 0x7FFFFF, exponent - 127);
            }
            return sign ? -result : result;
        }
    ]]).ieee754;

    terra Machine:getfloat(diskIndex:uint8, position:uint8)
        return ieee754(self.data[diskIndex].data[position], self.data[diskIndex].data[position+1], self.data[diskIndex].data[position+2], self.data[diskIndex].data[position+3]);
    end

    return terra()
        
        var currentDisk:uint8 = 0;
        var machine:Machine = Machine.new();
        br.io.printf("Loading disk\n");
        machine:load("./tools/example.braw"); 


        br.io.scanf("Hello, World!%d\n");
    end
};
// main;
set exports.main $main;